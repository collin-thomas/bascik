/**
 * Tests were generated by ChatGPT.
 * Test may have been modified by hand.
 */
import { describe, expect, it } from "vitest";

import {
  replaceTag,
  getTagContents,
  getFirstComponent,
  getTag,
  extractScriptTags,
  minifyHtml,
} from "./components.js";

describe("extractScriptTags", () => {
  it("should extract one script tag", () => {
    const htmlString =
      "<html><body><script>alert('hello world')</script></body></html>";
    const expected = "<script>alert('hello world')</script>";
    expect(extractScriptTags(htmlString)).toEqual(expected);
  });

  it("should extract multiple script tags", () => {
    const htmlString = `
      <html>
        <body>
          <script>alert('hello world')</script>
          <script>console.log('goodbye world')</script>
        </body>
      </html>`;
    const expected = `<script>alert('hello world')</script>\n<script>console.log('goodbye world')</script>`;
    expect(extractScriptTags(htmlString)).toEqual(expected);
  });

  it("should not extract script tags that are commented out", () => {
    const htmlString = `
      <html>
        <body>
          <!-- <script>alert('hello world')</script> -->
          <script>console.log('goodbye world')</script>
        </body>
      </html>`;
    const expected = `<script>console.log('goodbye world')</script>`;
    expect(extractScriptTags(htmlString)).toEqual(expected);
  });

  it("should return an empty string if no script tags are found", () => {
    const htmlString = "<html><body><div>Hello world</div></body></html>";
    const expected = "";
    expect(extractScriptTags(htmlString)).toEqual(expected);
  });
});

describe("replaceTag", () => {
  it("replaces a single tag", () => {
    const input = "<div>before</div><span>replace me</span><div>after</div>";
    const output = "<div>before</div><p>new tag</p><div>after</div>";
    expect(replaceTag(input, "span", "<p>new tag</p>")).toEqual(output);
  });

  it("replaces only the first instance of a tag", () => {
    const input =
      "<div>before</div><span>replace me</span><span>do not replace me</span><div>after</div>";
    const output =
      "<div>before</div><p>new tag</p><span>do not replace me</span><div>after</div>";
    expect(replaceTag(input, "span", "<p>new tag</p>")).toEqual(output);
  });

  it("does not modify input when tag not found", () => {
    const input = "<div>before</div><p>do not replace me</p><div>after</div>";
    expect(replaceTag(input, "span", "<p>new tag</p>")).toEqual(input);
  });

  it("preserves tag attributes", () => {
    const input =
      '<div>before</div><span class="important">replace me</span><div>after</div>';
    const output =
      '<div>before</div><p class="important">new tag</p><div>after</div>';
    expect(
      replaceTag(input, "span", '<p class="important">new tag</p>')
    ).toEqual(output);
  });

  it("is case-insensitive", () => {
    const input = "<div>before</div><SPAN>replace me</SPAN><div>after</div>";
    const output = "<div>before</div><p>new tag</p><div>after</div>";
    expect(replaceTag(input, "span", "<p>new tag</p>")).toEqual(output);
  });
});

describe("getTagContents", () => {
  it("gets contents of single tag", () => {
    const input = "<div>before</div><span>get me</span><div>after</div>";
    const output = { content: "<span>get me</span>", innerContent: "get me" };
    expect(getTagContents(input, "span")).toEqual(output);
  });

  it("gets contents of first matching tag", () => {
    const input =
      "<div>before</div><span>get me</span><span>not me</span><div>after</div>";
    const output = { content: "<span>get me</span>", innerContent: "get me" };
    expect(getTagContents(input, "span")).toEqual(output);
  });

  it("returns empty object when tag not found", () => {
    const input = "<div>before</div><p>do not get me</p><div>after</div>";
    const output = {};
    expect(getTagContents(input, "span")).toEqual(output);
  });

  it("preserves tag attributes", () => {
    const input =
      '<div>before</div><span class="important">get me</span><div>after</div>';
    const output = {
      content: '<span class="important">get me</span>',
      innerContent: "get me",
    };
    expect(getTagContents(input, "span")).toEqual(output);
  });

  it("is case-insensitive", () => {
    const input = "<div>before</div><SPAN>get me</SPAN><div>after</div>";
    const output = { content: "<SPAN>get me</SPAN>", innerContent: "get me" };
    expect(getTagContents(input, "span")).toEqual(output);
  });
});

describe("getTag", () => {
  const htmlString = `
    <div class="container">
      <h1>Welcome to my website</h1>
      <p>This is a test paragraph</p>
    </div>
  `;
  const componentList = {
    div: { className: "container" },
    h1: { style: { fontWeight: "bold" } },
  };

  it("returns content and inner content of tag", () => {
    const tagName = "p";
    const expectedOutput = {
      content: "<p>This is a test paragraph</p>",
      innerContent: "This is a test paragraph",
    };
    expect(getTag(htmlString, tagName)).toEqual(expectedOutput);
  });

  it("returns empty object when tag not found", () => {
    const tagName = "span";
    expect(getTag(htmlString, tagName)).toEqual({});
  });

  it("returns content, inner content and component properties", () => {
    const tagName = "h1";
    const expectedOutput = {
      content: "<h1>Welcome to my website</h1>",
      innerContent: "Welcome to my website",
      style: { fontWeight: "bold" },
    };
    expect(getTag(htmlString, tagName, componentList)).toEqual(expectedOutput);
  });
});

describe("getFirstComponent", () => {
  const componentList = {
    "tag-a": {
      fileName: "components/tag-a.html",
      fileContent: "<div><p>tag-a</p><slot-component></slot-component></div>",
    },
    "tag-b": {
      fileName: "components/tag-b.html",
      fileContent: "<div><p>tag-b</p><slot-component></slot-component></div>",
    },
    "tag-c": {
      fileName: "components/tag-c.html",
      fileContent: "<div><p>tag-c</p><slot-component></slot-component></div>",
    },
  };

  const htmlString = `<h1>Index</h1><tag-b></tag-b><tag-c></tag-c><my-footer></my-footer>`;

  it("should return an empty object when passed an empty string", () => {
    expect(getFirstComponent("", componentList)).toEqual({});
  });

  it("should return an empty object when no component is found in the string", () => {
    const htmlString = "<div><p>Hello World!</p></div>";
    expect(getFirstComponent(htmlString, componentList)).toEqual({});
  });

  it("should return the first component found in the string", () => {
    const expected = {
      name: "tag-b",
      index: 14,
      content: "<tag-b></tag-b>",
      innerContent: "",
      fileName: "components/tag-b.html",
      fileContent: "<div><p>tag-b</p><slot-component></slot-component></div>",
    };
    expect(getFirstComponent(htmlString, componentList)).toEqual(expected);
  });
});

describe("minifyHtml", () => {
  it("removes comments from HTML", () => {
    const htmlString = "<!-- comment --><div>content</div>";
    expect(minifyHtml(htmlString)).toEqual("<div>content</div>");
  });

  it("removes newlines and spaces from HTML, and removes extra spaces", () => {
    const htmlString = "<div>\n    \tcontent\n   \t</div>";
    expect(minifyHtml(htmlString)).toEqual("<div> content </div>");
  });

  it("removes comments, whitespace and newlines and puts script tags at the end of the HTML", () => {
    const htmlString = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Example</title>
        </head>
        <body>
          <h1>Hello, world!</h1>
          <p>This is an example page.</p>
          <!-- This is a comment -->
          <script>
            console.log("Hello, world!");
          </script>
          <script src="script.js"></script>
        </body>
      </html>
    `;
    const expected =
      '<!DOCTYPE html><html><head><title>Example</title></head><body><h1>Hello, world!</h1><p>This is an example page.</p></body></html>\n<script>\n            console.log("Hello, world!");\n          </script>\n<script src="script.js"></script>';

    const result = minifyHtml(htmlString);
    expect(result).toBe(expected);
  });

  it("handles an empty input string", () => {
    expect(minifyHtml("")).toEqual("");
  });
});
